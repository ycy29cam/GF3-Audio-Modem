import scipy.fft
import Constants
import numpy as np
import scipy
import sounddevice as sd
import time
import matplotlib.pyplot as plt
from Constants import *

def chirp(fstart,fend, duration, fs,):
    """
    Generate a chirp signal.
    :param fstart: Start frequency of the chirp in Hz
    :param fend: end frequency of the chirt in Hz
    :param duration: Duration of the chirp in seconds
    :param fs: Sampling frequency in Hz
    :return: Chirp signal
    """
    t = np.linspace(0, duration, int(fs * duration), endpoint=False)
    return scipy.signal.chirp(t, f0=fstart, f1=fend, t1=duration, method='linear') * 1.5

def OFDM_pilot(length):
    """
    Generates a random array of constellation symbols
    Uses a fixed seed for random generation
    4 symbol grey code mapping
    :param length: Length of pilot in symbols
    :return: outputs array dimension (2*length - 2 bits) for even block lengths, of QPSK symbols mapped to time domain
    :QUESTION: how best should the 2 bit discrepancy be handled (note 2*length - 1 = odd o/p length)
    """
    np.random.seed(seed=42)
    B_matrix = np.random.randint(2, size=(length,2))
    symbol_map = {
        (0, 0): 1 + 1j,
        (0, 1): -1 + 1j,
        (1, 1): -1 - 1j,
        (1, 0): 1 - 1j
    }
    x = np.array([symbol_map[tuple(b)] for b in B_matrix]) # x is useful data randomly generated by given seed
    x[[0,-1]] = [0,0] # ensures 0 mean conjugate symmetric signal
    x = np.asarray(x, dtype=np.complex128) # ensures the generated data is an array
    y = np.concatenate([x, np.conj(x[-2:0:-1])]) # y is useful data with conjugate symmetry in freq domain
    return np.real(scipy.fft.ifft(y)) #computes IFFT of the data


def noise(length):
    np.random.seed(seed=42)
    noise = np.random.normal(0, 1, length).astype('float32')
    return noise

"-------------------------------Emission Code-----------------------------------"

#print(OFDM_pilot(4))

def sequence_generator(length = None):
    if length is None:
        length = int((BLOCK_LENGTH + 2) / 2)

    silence = np.zeros(int(0.05 * SAMPLE_RATE))
    symbol = OFDM_pilot(length)*50
    #length formula used to ensure a block length - check carefully is changing block_length that length still = even 
    prefixed_symbol = np.concatenate((symbol[-CP:],symbol ))
    chirp_start = chirp(20,15000, 2, fs = SAMPLE_RATE)
    chirp_end = chirp(15000,20, 2, fs = SAMPLE_RATE)
    

    signal = np.concatenate((silence, chirp_start, prefixed_symbol, np.tile(symbol, 3), chirp_end), axis=0) # may need a prefix for chirp_end at some point
    return signal






if __name__ == "__main__":
    # signal generation test + amplitude plot
    print(sequence_generator())
    plt.figure(figsize=(10, 4))
    plt.plot(np.abs(sequence_generator()))
    plt.title('Signal Plot')
    plt.xlabel('Sample Index')
    plt.ylabel('Amplitude')
    plt.grid(True)
    plt.tight_layout()
    plt.show()


sd.play(sequence_generator(), samplerate=SAMPLE_RATE)
#sd.play(chirp(100,20000,2,SAMPLE_RATE), samplerate=SAMPLE_RATE)
#sd.play(noise(BLOCK_LENGTH*20), samplerate=SAMPLE_RATE)
sd.wait()

